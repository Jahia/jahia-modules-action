name: 'Integration tests'
description: 'Runs Jahia integration tests on an Ubuntu server'
inputs:
  module_id:
    description: 'Module ID'
    required: true
  nexus_username:
    description: 'Nexus Username'
    required: true
  nexus_password:
    description: 'Nexus Password'
    required: true
  docker_username:
    description: 'Docker login username'
    required: true
  docker_password:
    description: 'Docker login password'
    required: true
  docker_compose_file:
    description: 'Filename for docker-compose yaml file'
    default: 'docker-compose.yml'
  tests_path:
    description: 'Folder containing the docker-compose.yml'
    default: 'tests/'
  tests_manifest:
    description: 'Manifest contraining the provisioning script'
    required: true
  jahia_image:
    description: 'Full name of a Jahia image (org/repo:tag)'
    default: ''
  jahia_superuser_password:
    description: 'Jahia root password'
    default: 'root1234'
  jahia_cluster_enabled:
    description: 'Run Jahia in cluster mode'
    default: false
  tests_image:
    description: 'Full name of the Tests image (org/repo:tag)'
    default: 'module-tests'
  tests_container_name:
    description: 'Name of the tests container in the docker-compose file'
    default: 'cypress'
  tests_container_branch:
    description: 'Branch containing the tests (if different from current)'
    default: 'cypress'
  jahia_license:
    description: 'Base64 encoded License'
    default: ''
  jcustomer_image:
    description: 'Full name a JCustomer image (org/repo:tag)'
    default: ''
  elasticsearch_image:
    description: 'Full name of an Elasticsearch image (org/repo:tag)'
    default: ''
  should_skip_artifacts:
    description: 'Should build artifacts be copied in the test container ?'
    default: false    
  should_skip_testrail:
    description: 'Should the submission to Testrail be skipped ?'
    default: true
  should_skip_notifications:
    description: 'Should slack notifications be skipped ?'
    default: true
  slack_channel_id_notifications:
    description: 'Channel id to be used for failure notifications'
    default: ''    
  slack_channel_id_notifications_all:
    description: 'Channel id to be used for all notifications (failure and success)'
    default: ''
  slack_client_token:
    description: 'The slack token used to post the messages'
    default: ''
  slack_webhook_notifications:
    description: 'Webhook to be used for failure notifications'
    default: ''
  slack_webhook_notifications_all:
    description: 'Webhook to be used for all notifications (failure and success)'
    default: ''
  should_skip_zencrepes:
    description: 'Should zencrepes notifications be skipped ?'
    default: false
  should_build_testsimage:
    description: 'Should the orb attend to build the test image ?'
    default: true
  zencrepes_secret:
    description: 'ZenCrepes Webhook secret'
    default: ''
  incident_pagerduty_api_key:
    description: 'Pageduty API key to create incidents'
    default: ''
  incident_pagerduty_reporter_email:
    description: 'Pageduty Reporter email to create incident. That email must correspond to a valid user in the PagerDuty tenant'
    default: ''
  incident_pagerduty_reporter_id:
    description: 'Pageduty Reporter id to create incident. This user will first be assigned to the ticket when --pdTwoStepsAssign is provided'
    default: ''
  incident_google_spreadsheet_id:
    description: 'Google Spreadsheet ID of the spreadsheet containing the incident mapping'
    default: ''
  incident_google_client_email:
    description: 'Google Client email to allow access to Google API'
    default: ''
  incident_google_api_key_base64:
    description: 'Google base64 encoded private key to allow access to Google API'
    default: ''
  testrail_project:
    description: 'Testrail Project to send data to'
    default: 'Default'    
  testrail_milestone:
    description: 'Milestone to be used when submitting the results to Testrail'
    default: 'Default'
  testrail_username:
    description: 'Testrail Username'
    default: ''
  testrail_password:
    description: 'Testrail Password'
    default: ''
  ci_startup_script:
    description: 'Startup script to use in-lieu of docker-compose up'
    default: 'ci.startup.sh'
  ci_postrun_script:
    description: 'Script to run prior to saving the artifacts'
    default: 'ci.postrun.sh'
defaults:
  run:
    shell: bash
runs:
  using: "composite"
  steps:
    - uses: actions/setup-node@v2
      with:
        node-version: 'lts/*'
    - run: | 
        echo "Install needed packages"
        npm install -g jahia-reporter
      shell: bash

    # Set the environment variables necessary for the docker-compose run
    # These are declared here to avoid having to repeat in multiple steps
    - run: |
        echo "Set environment variables from parameters"
        echo "MANIFEST=${{ inputs.tests_manifest }}" >> $GITHUB_ENV
        echo "JAHIA_IMAGE=${{ inputs.jahia_image }}" >> $GITHUB_ENV
        echo "JAHIA_LICENSE=${{ inputs.jahia_license }}" >> $GITHUB_ENV
        echo "JAHIA_CLUSTER_ENABLED=${{ inputs.jahia_cluster_enabled }}" >> $GITHUB_ENV
        echo "TESTS_IMAGE=${{ inputs.tests_image }}" >> $GITHUB_ENV
        echo "JCUSTOMER_IMAGE=${{ inputs.jcustomer_image }}" >> $GITHUB_ENV
        echo "ELASTICSEARCH_IMAGE=${{ inputs.elasticsearch_image }}" >> $GITHUB_ENV
        echo "NEXUS_USERNAME=${{ inputs.nexus_username }}" >> $GITHUB_ENV
        echo "NEXUS_PASSWORD=${{ inputs.jahia_image }}" >> $GITHUB_ENV
        echo "JAHIA_IMAGE=${{ inputs.nexus_password }}" >> $GITHUB_ENV
      shell: bash
    - run: |
        echo "Display important versions and environment variables"
        echo "node -v: $(node -v)"
        echo "npm -v: $(npm -v)"
        echo "jahia-reporter -v: $(jahia-reporter -v)"
        echo "Displaying important environment variables"
        echo "MANIFEST=${MANIFEST}"
        echo "JAHIA_IMAGE=${JAHIA_IMAGE}"
        echo "TESTS_IMAGE=${TESTS_IMAGE}"
        echo "JCUSTOMER_IMAGE=${JCUSTOMER_IMAGE}"
        echo "ELASTICSEARCH_IMAGE=${ELASTICSEARCH_IMAGE}"        
      shell: bash      
    - run: |
        echo "Prepare export folder"
        mkdir -p ${{ inputs.tests_path }}artifacts
      shell: bash
  
    # Login to the docker registry is needed to access some images (snapshots, ...)
    - run: echo "${{ inputs.docker_password }}" | docker login -u "${{ inputs.docker_username }}" --password-stdin
      shell: bash

    - run: |
        if [ ${{ inputs.should_skip_artifacts }} == false ]; then
          echo "Preparing build artifacts"
          find . -type f -path '*/target/*-SNAPSHOT.jar' -exec cp '{}' ${{ inputs.tests_path }}artifacts/ ';' || :
          if [ -d ./build-dependencies/ ]; then
            mkdir -p ${{ inputs.tests_path }}artifacts/build-dependencies
            cp ./build-dependencies/* ${{ inputs.tests_path }}artifacts/build-dependencies/
            echo "Content of build-dependencies"
            ls -lah ${{ inputs.tests_path }}artifacts/build-dependencies/
          fi
          ls -lah ${{ inputs.tests_path }}artifacts
        fi   
      shell: bash

    # We always build the test container from scratch
    # Docker layer caching makes this quick if it was already previously built
    # To test a previous release, a specific branch can be provided      
    - run: |
        if [ ${{ inputs.should_build_testsimage }} == true ]; then
          echo "Build the tests image"
          cd ${{ inputs.tests_path }}
          if [[ "${{ inputs.tests_container_branch }}" != "" ]]; then
            git checkout ${{ inputs.tests_container_branch }}
          fi
          docker build -t ${{ inputs.tests_image }} .
          docker save -o tests_image.tar ${{ inputs.tests_image }}
        fi    
      shell: bash

    # Pull the latest version of ${JAHIA_IMAGE}  
    - run: |
        echo "Pull the latest version of Jahia and print docker images cache to console"
        cd ${{ inputs.tests_path }}
        . ./set-env.sh
        echo "List of docker images in local cache PRIOR pull" > ./artifacts/docker.log
        docker images --digests --all 2>&1 | tee -a ./artifacts/docker.log
        echo "--------------------------------------------------" >> ./artifacts/docker.log
        docker pull ${JAHIA_IMAGE}
        echo "List of docker images in local cache AFTER pull" >> ./artifacts/docker.log
        docker images --digests --all 2>&1 | tee -a ./artifacts/docker.log
        echo "--------------------------------------------------" >> ./artifacts/docker.log  
      shell: bash      

    # Run a background task to display the running containers and their hash
    # This is used to verify that the right containers are running
    # Sleep 30s to give containers time to start
    # - run: |
    #     cd ${{ inputs.tests_path >>
    #     sleep 30
    #     docker ps --all --no-trunc 2>&1 | tee -a ./artifacts/docker.log
    #   shell: bash 

    # Using abort-on-container-exit will exit on first container failure, which
    # for us will be the test container
    - run: |
        echo "Spin-up the containers"
        export DOCKER_CLIENT_TIMEOUT=120
        export COMPOSE_HTTP_TIMEOUT=120
        . ./set-env.sh
        if [[ -f "${{ inputs.ci_startup_script }}" ]]; then
          echo "Startup script is present"
          bash ${{ inputs.ci_startup_script }}
        else
          docker-compose -f ${{ inputs.docker_compose_file }} up --abort-on-container-exit
        fi         
      shell: bash  

    - run: |
        echo "Export containers artifacts (reports, secreenshots, videos)"
        cd ${{ inputs.tests_path }}
        docker cp ${{ inputs.tests_container_name }}:/home/jahians/results ./artifacts         
      shell: bash       

    # Running logs with -t adds a timestamp, this might feel redundant with the timestamp provided
    # by directly jahia but this allows for easy comparison between various containers that might
    # have their timezone set differently
    - run: |
        echo "Export containers logs"
        cd ${{ inputs.tests_path }}
        docker-compose logs -t --tail="all" > ./artifacts/results/all-containers.log
        docker logs jahia > ./artifacts/results/jahia.log
        docker logs ${{ inputs.tests_container_name }} > ./artifacts/results/${{ inputs.tests_container_name }}.log
        cp ./artifacts/docker.log ./artifacts/results/       
      shell: bash

    - run: |
        echo "Analyze Test results"
        cd ${{ inputs.tests_path }}
        if [[ ! -e ./artifacts/results/test_success ]]; then
          echo "More than one failure found, sending exit signal"
          exit 1
        fi     
      shell: bash      

    # If a ci.postrun.sh script is present, this script is executed
    # The main purpose of this script is to export additional artifacts,
    # capture logs from other containers, ...    
    - run: |
        cd ${{ inputs.tests_path }}
        export DOCKER_CLIENT_TIMEOUT=120
        export COMPOSE_HTTP_TIMEOUT=120
        ls -lah
        . ./set-env.sh
        if [[ -f "${{ inputs.ci_postrun_script }}" ]]; then
          echo "Postrun script is present"
          bash ${{ inputs.ci_postrun_script }}
        fi      
      shell: bash
